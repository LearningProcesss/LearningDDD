# Domain

## Enitity

As developers we tend to focus on data rather than the domain,
instead of designing domain concepts with rich behaviours we might think primarly about database side like attribues (columns) and associations (FK).  
This approch leads to so called ***Entity*** abounding of public get and set that do not describes any behaviour.  

***Entity*** is an unique thing and is capable of being changed continuosly but is always recognizable by its own ***Identity***.  
It differs from ***Value Object*** beause of it's identity.  
In a CRUD system everithing is a value but a system like that can't stands   
when comlexity grows, too complicated business rules comes in, and where DDD and Entity shines with a low control level.  

***Entity*** is composed by ***Unique Identity***, attributes expressed as primitives, collection or ***Value Object*** and by behaviours expressed with by methods or delegated to ***Value Object***.

### Unique Identity

> In the early stage of designing ***Entity*** focus only on primary attributes\characteristics particurarly on those that identify it and add behaviour that is essential to the concept and attributes that are requireds by that behaviour.

Can be a primitive like Guid, string, int, long or ***Value Object*** that serves as holders of the Entiti's unique identity with specific and centralized behaviour.  

Identity stability is mandatory for the entire Entiti's lifecycle.  
Private setters or Guard must be used to hide or prevent field used as or part of the Identity.

***Common Identity creation strategies***

1.  *User Provides Identity*  
    User provides data used to generate Identity, this approach is initially cheap, but,    
    are those good quality data? like a "Title" field can be mispelled or simply incorrect and user wants to change it in the future. Identity are readonly and immutable.
2.  *Application Generates Identity*  
    GUID is a fast standard approach that can be autogenerated or by a given text.
    In a time critical business lot of GUID can be preallocated to a cache.   
    Custom UUID\string (not compatible GUID) can be composed to be more readable not ony for clients but for developers and can contains specific words of the ***Bounded Context*** where it was generated like APM-P-08-14-2012-F36AB21C  (APM = Boundend Context) (P = Product Entity type) (08-12-2012 = creation date) (F36AB21C = first segment of autogenerated GUID)  
    Identity creation, that is a detail, is not matter of ***Domain*** but ***Infrastructure***. Can be ***Repository*** (for ***Aggregate***) or ***Factory*** or External Service as well.  
    A ***Value Object*** is far more suitable to hold this information rather than in a string.  (my assumption: Value Object is used to hold Identity and expose only interpretation and not creational behaviour)  
    Using a ***Value Object*** as Identity holder prevent a so called shotgun surgery if you decide to change identity type of your ***Entity*** or ***Aggregate***

    ```c#
    // Vaughn Vernon
    public class ProductRepository : IProductRepository
    {
        public Guid NextIdAutoGenerated() 
        {
            return Guid.NewGuid();
        }

        // my assumption
        public string NextIdComposed()
        {
            string boundedContext = "..";
            string type = "..";
            string date = "..";
            string guid = Guid.NewGuid().ToString().Substring(..);
            return $"{boundedContext}-{type}-{date}-{guid}";
        }
    }

    public class ProductId : ValueObject
    {
        private readonly id;

        public ProductId(string id)
        {
            this.id = id;
        }

        public string GeneratedFromBoundedContext()
        {
            return this.id..;
        }
    }

    public class Product : Entity
    {
        private ProductId productId;

        public Product(ProductId productId..)
        {
            ..
        }

        public string GeneratedFromBoundedContext()
        {
            return productId.GeneratedFromBoundedContext();
        }
    } 
    ```

    ```c#
    // Scott Millet e Nick Tunes
    // pag. 363 - 369
    // They dont use Repository but Factory for static incremental number generation.
    // Custom UUID\string creation is matter of the Entity itself:

    public class HolidayBooking 
    {
        public string Id { get; private set; }

        public HolidayBooking(int travelerId, DateTime fistNight, DateTime lastNight, DateTime booked)
        {
            ..
            this.Id = GenerateId(travelerId, firstNight, lastNight, booked);
        }

        private string GenerateId(int travelerId, DateTime fistNight, DateTime lastNight, DateTime booked)
        {
            return string.Format("{0}-{1}-{2}-{3}", travelerId, fistNight, lastNight, booked);
        }
    }
    ```
    Questions:  
    If Repository generates Id only for Aggregate, who generate Entity Ids contained in the Aggregate boundary?
3.  *Persistence Mechanism Generates Identity*  
    Persitence mechanism is always sure to be unique. The trade off is performance.  
    A cache mechanism to store a number of preallocated identities is viable if the trade off of loosing them at restart is not a problem.  
    Sometimes it matters when the identity generation and assignment occur for an Entity and only if the Entntiy can lives without identity for a while.  
    *Early identity generation*: before Entity is persisted.
    *Late identity generation*: when the Entity is peristed.
    One possibile solution for *Early identity generation* is to create a SQL Table with a single integer\long column that will store "nextval" and the repository get this value and immediatly after update the table with nextval + 1.
4.  *Another Bounded Context Assigns Identity*   
    TODO

***When Timing of Identity Generation Matters***


***Surrogate Identity***


### 



## Aggregate