# Domain

## Enitity

As developers we tend to focus on data rather than the domain,
instead of designing domain concepts with rich behaviours we might think primarly about database side like attribues (columns) and associations (FK).  
This approch leads to so called ***Entity*** abounding of public get and set that do not describes any behaviour.  

***Entity*** is an unique thing and is capable of being changed continuosly but is always recognizable by its own ***Identity***.  
prior to that differs from ***Value Object***.  
In a CRUD system everithing is a value but a system like that can't stands   
when comlexity grows, too complicated business rules comes in, and where DDD and Entity shines with a low control level.  

***Entity*** is composed by ***Unique Identity***, attributes expressed by primitives, collection and by behaviours expressed with by methods or delegated to ***Value Object***.

### Unique Identity

> In the early stage of designing ***Entity*** focus only on primary attributes\characteristics particurarly on those that identify it and add behaviour that is essential to the concept and attributes that are requireds by that behaviour.

Can be a primitive like Guid, string, int, long or ***Value Object*** that serves as holders of the Entiti's unique identity with specific and centralized behaviour.  

Identity stability is mandatory for the entire Entiti's lifecycle.  
Private setters or Guard must be used to hide or prevent field used as or part of the Identity.

Two Entities are considered equal if they have same Identity even when they have rest of the state completly different or just one property.

***Common Identity creation strategies***

1.  *User Provides Identity*  
    User provides data used to generate Identity, this approach is initially cheap, but,    
    are those good quality data? like a "Title" field can be mispelled or simply incorrect and user wants to change it in the future. Identity are readonly and immutable.
2.  *Application Generates Identity*  
    GUID is a fast standard approach that can be autogenerated or by a given text.
    In a time critical business lot of GUID can be preallocated to a cache.   
    Custom UUID\string (not compatible GUID) can be composed to be more readable not ony for clients but for developers and can contains specific words of the ***Bounded Context*** where it was generated like APM-P-08-14-2012-F36AB21C  (APM = Boundend Context) (P = Product Entity type) (08-12-2012 = creation date) (F36AB21C = first segment of autogenerated GUID)  
    Identity creation, that is a detail, is not matter of ***Domain*** but ***Infrastructure***. Can be ***Repository*** (for ***Aggregate***) or ***Factory*** or External Service as well.  
    A ***Value Object*** is far more suitable to hold this information rather than in a string.  (my assumption: Value Object is used just to hold Identity and expose only interpretation and not creational behaviour)  
    Using a ***Value Object*** as Identity holder prevent a so called "shotgun surgery" if you decide to change identity type of your ***Entity*** or ***Aggregate***

    ```c#
    // Vaughn Vernon
    public class ProductRepository : IProductRepository
    {
        public Guid NextIdAutoGenerated() 
        {
            return Guid.NewGuid();
        }

        // my assumption
        public string NextIdComposed()
        {
            string boundedContext = "..";
            string type = "..";
            string date = "..";
            string guid = Guid.NewGuid().ToString().Substring(..);
            return $"{boundedContext}-{type}-{date}-{guid}";
        }
    }

    public class ProductId : ValueObject
    {
        private readonly id;

        public ProductId(string id)
        {
            this.id = id;
        }

        public string GeneratedFromBoundedContext()
        {
            return this.id..;
        }
    }

    public class Product : Entity
    {
        private ProductId productId;

        public Product(ProductId productId..)
        {
            ..
        }

        public string GeneratedFromBoundedContext()
        {
            return productId.GeneratedFromBoundedContext();
        }
    } 
    ```

    ```c#
    // Scott Millet e Nick Tunes
    // pag. 363 - 369
    // They dont use Repository but Factory for static incremental number generation.
    // Custom UUID\string creation is matter of the Entity itself:

    public class HolidayBooking 
    {
        public string Id { get; private set; }

        public HolidayBooking(int travelerId, DateTime fistNight, DateTime lastNight, DateTime booked)
        {
            ..
            this.Id = GenerateId(travelerId, firstNight, lastNight, booked);
        }

        private string GenerateId(int travelerId, DateTime fistNight, DateTime lastNight, DateTime booked)
        {
            return string.Format("{0}-{1}-{2}-{3}", travelerId, fistNight, lastNight, booked);
        }
    }
    ```
    Questions:  
    If Repository generates Id only for Aggregate, who generate Entity Ids contained in the Aggregate boundary?
3.  *Persistence Mechanism Generates Identity*  
    Persitence mechanism is always sure to be unique. The trade off is performance.  
    A cache mechanism to store a number of preallocated identities is viable if the trade off of loosing them at restart is not a problem.  
    Sometimes it matters when the identity generation and assignment occur for an Entity and only if the Entntiy can lives without identity for a while.  
    *Early identity generation*: before Entity is persisted.
    *Late identity generation*: when the Entity is peristed.
    One possibile solution for *Early identity generation* is to create a SQL Table with a single integer\long column that will store "nextval" and the repository get this value and immediatly after update the table with nextval + 1.
4.  *Another Bounded Context Assigns Identity*   
    TODO

***When Timing of Identity Generation Matters***


***Surrogate Identity***


### Design Entity

Using ***Ubiquitos Language*** and speaking with domain experts design an entity stripping down with requirements

***Characteristics***

- recognised by requirements, is the object uniquely identified? should the object support changes over time?  
  If both yes the object is clearly an ***Entity***
- what are those properties that never can be changed and define the entity identity?
- which type of ***Identity***? simple string\Guid\long or ***Value Object***?
- what are the most basic propertyies immediately implementable?
- skip Aggregate at first, but take note for future.

***Behaviours***

- Should be behaviour oriented. Entity should expose expressive methods taht communicate domain beahviour instead of exposing state.  
- encapsulate behaviour in Entity method but avoid placing too much responsability to Entity.  
  Delegate to a ***Value Object***, part of the Entity, logical group of immutable data and behaviours.  
  Ideally, you should always put most of the business logic into value objects. Entities in this situation would act as wrappers upon them and represent more high-level functionality.  
  Recognize Value Object when data are immutable but belongs to the Entity.  
  Depth object graph accepted is 3 like Entity.ValueObject.ValueObjectBehaviour
- Try to model all state altering operations as verbs that correspond to business operations. A setter will only tell you what property you are changing but not why.
- if you dont find a perfect fit for a behaviour in any Entity maybe higher level coordinator is needed, place this beahaviour in ***Domain Service***

### Construction

When instantiate and Entity use a constructor that captures enough state to fully identify it and enable clients to find it.  
If you use early identity generation it must be passed to constructor.
Each constructor parameter must be delegated to the respective setter that self-encapsulate contractual condition (validation).  
Use a ***Factory*** for complex Entity instantiation.  

### Validation

There are three major validation "type": **Validating Attributes/Properties**, **Validating Whole Object**, **Validating Composition of objects**.  

One of the main aspect is that an ***Entity*** must always have consistent state (always valid) but "always contextually valid" also.  
"always valid" can be achieved with **self-encapsulation** validation and tryExecute pattern.     
"always contextually valid" when your validation have to be aligned with business requirements.

**Invariants** are generally business rules/enforcements/requirements that you impose to maintain the integrity of an object at any given time.  

You can think about **validation** as the process of approving a given object state,  
while **invariant** enforcement happens before that state has even been reached.  

***Validating Attributes/Properties***

Use property self-encapsulation to prevent any type of invalid state on both ***Entity*** and ***Value Object***.

> self-encapsulation  
Design your classes so that all access to data, even fron within the same class, goes through accessor methods

```c#
/*
Value Object EmailAddress is "always valid" thanks to the self-encapsulation made at initialization time, it's state is guarantee that is always consistent and valid.
*/
public class EmailAddress 
{
    private string emailAddress { get; private set; }

    public EmailAddress(string emailAddress)
    {
        SetEmailAddress(emailAddress);
    }

    private void SetEmailAddress(string emailAddress)
    {
        DomainExcpetionOfYourType.ThrowIfNullOrEmpty(emailAddress, nameof(emailAddress));

        if(emailAddress.lenght > 100)
        {
            throw new DomainExcpetionOfYourType();
        }

        if(!emailAddress.regex..)
        {
            throw new DomainExcpetionOfYourType();
        }
    }
}

/*
Entity FlighBooking is "always contextually valid" when it's behaviour Reschedule is invoked.
It ensure through business policy that a fligh cant be changed if confirmed. 
*/
public class FlighBooking
{
    public DateTime Departure { get; private set; }
    
    private bool confirmed = false;

    public FlighBooking(Guid id, DateTime departureDate)
    {
        // self-encapsulation
    }

    public void Reschedule(DateTime newDeparture)
    {
        if(confirmed) { throw new DomainExcpetionOfYourType(); }

        Departure = newDeparture;
    }

    public void Confirm()
    {
        confirmed = true;
    }
}


```

***Validating Whole Object***



## Resources used for this topic

|link|reasons|
|---|--|
|https://vaadin.com/blog/ddd-part-2-tactical-domain-driven-design|Entity behaviors|
|https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/|Where place behaviours|
|https://stackoverflow.com/questions/30190302/what-is-the-difference-between-invariants-and-validation-rules|Validation and invariants|

## Aggregate